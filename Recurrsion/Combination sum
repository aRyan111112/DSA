//* My approach *// using extra variable "sum"

class Solution {

    public void ss(int i, int[] candidates, int target, List<List<Integer>> ansList, List<Integer> elements, int sum) {

        if(sum == target) {
            ansList.add(new ArrayList<>(elements));
            return;
        }
        if(sum > target || i>=candidates.length) {
            return;
        }

        elements.add(candidates[i]);

        ss(i, candidates, target, ansList, elements, sum + candidates [i]);

        elements.remove(elements.size()-1);
        ss(i+1, candidates, target, ansList, elements, sum);

    }
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> ansList = new ArrayList<>();
        List<Integer> elements = new ArrayList<>();

        ss(0, candidates, target, ansList, elements, 0);
        return ansList;
        
    }
}
--------------------------------------------------------------------------------------------------------------------
//* Without using extra variable (By modifying target only) 

Intution - 
if we subtract target from the elements than at some point target will either become zero 
(i.e till here elements sum is equal to target) or a less than zer0 (i.e elements sum to give more than target).


class Solution {


    public void ss(int i, int[] candidates, int target, List<List<Integer>> ansList, List<Integer> elements) {
        // if the target becomes zero then elements add up to give target
        if(target == 0) {
            ansList.add(new ArrayList<>(elements));
            return;
        }

        // if target<0, that means elements adds upto give more than target, or if array get over
        if(target < 0 || i >= candidates.length) {
            return;
        }

        elements.add(candidates[i]);
        // if target is greater than zero than, call for same index value
        ss(i, candidates, target-candidates[i], ansList, elements);

        // if the any base case satisfies backtrak and call for next array element
        elements.remove(elements.size()-1);
        ss(i+1, candidates, target, ansList, elements);

    }
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> ansList = new ArrayList<>();
        List<Integer> elements = new ArrayList<>();

        ss(0, candidates, target, ansList, elements);
        return ansList;   
    }
}
